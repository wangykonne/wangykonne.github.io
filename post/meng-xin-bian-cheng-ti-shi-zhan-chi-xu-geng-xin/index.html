<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>萌新编程题实战（持续更新） | db自留地</title>

<link rel="shortcut icon" href="https://wangykonne.github.io/favicon.ico?v=1616725771639">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://wangykonne.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            db自留地
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1616725771639"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    萌新编程题实战（持续更新）
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-03-20 ·
                    </time>
                    
                        <a href="https://wangykonne.github.io/tag/BI-XY98Ii/" class="post-tags">
                            # 算法岗知识
                        </a>
                    
                </div>
                <div class="post-content">
                    <blockquote>
<p>我太菜了，做得又慢又复杂Orz</p>
</blockquote>
<!-- more -->
<h2 id="字节-房间题">字节-房间题</h2>
<h3 id="题目描述">题目描述</h3>
<p>  有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, ... 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。</p>
<h3 id="输入描述">输入描述</h3>
<p>  第一行两个整数n, x (1&lt;=x&lt;=n)，代表房间房间数量以及最后一个人被分配的房间号；<br>
第二行n个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，代表每个房间分配后的人数。</p>
<h3 id="输出描述">输出描述</h3>
<p>  输出n个整数，代表每个房间分配前的人数。</p>
<h3 id="示例">示例</h3>
<pre><code>输入：
3 1
6 5 1    
输出：
4 4 4
</code></pre>
<h3 id="思路与解答">思路与解答</h3>
<p>  我的想法是从末状态进行倒推，从x位置-1然后到x-1位置再-1。而终止情况就是在某个位置人数-1之后，其前一个位置的人数恰好为0，此时刚好说明回到了原始状态。代码如下：</p>
<pre><code class="language-python">information = input().split()
n = int(information[0])
x = int(information[1])
n_number = input().split()
a = [int(n_number[i]) for i in range(len(n_number))]
i = 0
#反向移动函数
def move(m):
    if m != 1:
        m -= 1
    else:
        m = n  
    return m
#倒推到初始情况
while a[x-1] != 0:
    a[x-1] -= 1
    x = move(x)
    i += 1
#补上人被清空的初始房间
a[x-1] = i
result = ''
for i in range((len(a))-1):
    result += str(a[i])+' '
print(result+str(a[-1]))
</code></pre>
<h2 id="字节-移动房间题">字节-移动房间题</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>  存在n+1个房间，每个房间依次为房间1 2 3...i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1&lt;=pi&lt;=i),现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；现在路人甲想知道移动到房间n+1一共需要多少次移动；</p>
<h3 id="输入描述-2">输入描述</h3>
<p>  第一行包括一个数字n，表示房间的数量，接下来一行存在n个数字 pi(1&lt;=pi&lt;=i), pi表示从房间i可以传送到房间pi。</p>
<h3 id="输出描述-2">输出描述</h3>
<p>  输出一行数字，表示最终移动的次数。</p>
<h3 id="示例-2">示例</h3>
<pre><code>输入：
2
1 2
输出：
4
</code></pre>
<p>  说明：开始从房间1只访问一次所以只能跳到p1即房间1， 之后采用策略A跳到房间2，房间2这时访问了一次因此采用策略B跳到p2房间即房间2，之后采用策略A跳到房间3，因此到达房间3需要4步操作。</p>
<h3 id="思路与解答-2">思路与解答</h3>
<p>  我的想法比较简单粗暴，用一个list-at储存下路人的移动轨迹，但移动到n+1时停止。同时写一个函数num(i)来表示路人目前到i房间多少次了，而有移动轨迹at的话这个计数只要比对at=i的次数就可以了。代码如下：</p>
<pre><code class="language-python">n = int(input())
pi = input().split()
at = [1]
#访问房间i的次数函数
def num(i):
    k = 0
    for j in range(len(at)):
        if at[j]==i:
            k+=1
    return k
step = 0
#随移动更新轨迹at，到n+1房间停止
while at[step]!=(n+1):
    if num(at[step])%2 == 1:
        at.append(int(pi[at[step]-1]))
    else:
        at.append(at[step]+1)
    step+=1
print(step)
</code></pre>
<h2 id="字节-片段字符串长度题">字节-片段字符串长度题</h2>
<h3 id="题目描述-3">题目描述</h3>
<p>  有一个仅包含’a’和’b’两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个’a’设置为’b’，或者把一个’b’置成’a’)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少？</p>
<h3 id="输入描述-3">输入描述</h3>
<p>  第一行两个整数 n , m，第二行为长度为n且只包含’a’和’b’的字符串s。</p>
<h3 id="输出描述-3">输出描述</h3>
<p>  输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全’a’子串或全’b’子串的长度。</p>
<h3 id="示例-3">示例</h3>
<pre><code>输入：
8 1
aabaabaa
输出：
5
</code></pre>
<p>  说明：把第一个 'b' 或者第二个 'b' 置成 'a'，可得到长度为 5 的全 'a' 子串。</p>
<h3 id="思路与解答-3">思路与解答</h3>
<p>  首先分析需要什么功能，显然需要一个函数能返回一个字符串中最长片段a或b的长度，正巧之前学了点正则表达式，所以可以用正则表达式取出字符串中所有的a片段或b片段，返回最长片段的长度。其次，需要变化ab若干，不管变化多少次都可以用1次递归，所以我写了个函数change1(string,i)表示将string的第i个位置的a变为b或b变为a，返回变换后的新字符串。<br>
  解这道题的思路类似贪心算法——每次变换达到最大长度的字符串保留为新字符串然后继续递归执行m次（虽然每一步最优不一定合起来就是总体最优，但这道题貌似就是总体最优），有上面这两个函数，以变换一次为例，可以找到变换一次能达到的最长片段长度和对应的新字符串，然后递归m次，用序列储存m次变换对应的长度，取最大值即可。代码如下：</p>
<pre><code class="language-python">import re
npm = input().split()
n = int(npm[0])
m = int(npm[1])
abstr = input()
#计算最大片段长度
def count(string):
    resulta = re.findall('[a]+',string)
    resultb = re.findall('[b]+',string)
    la = [len(resulta[i]) for i in range(len(resulta))]
    lb = [len(resultb[i]) for i in range(len(resultb))]
    return max(max(la),max(lb))
#得到变换i位置后的新字符串
def change1(string,i):
    l = list(string)
    if l[i]=='a':
        l[i] = 'b'
    else:
        l[i] = 'a'
    return ''.join(l)
ans = [0 for i in range(m)]
j = 0
#每次变换更新能得到最大片段长的新字符串为abstr进行下一轮循环
while j&lt;=(m-1):
    length = [count(change1(abstr,i)) for i in range(n)]
    ans[j] = max(length)
    maxindex = sorted(range(len(length)), key=lambda k: length[k], reverse=True)[0]
    abstr = change1(abstr, maxindex)
    j+=1
print(max(ans))
</code></pre>
<h2 id="1269停在原地的方案数">1269.停在原地的方案数</h2>
<h3 id="题目描述-4">题目描述</h3>
<p>  有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。由于答案可能会很大，请返回方案数 模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 后的结果。</p>
<h3 id="示例-4">示例</h3>
<pre><code>输入：steps = 3, arrLen = 2
输出：4
解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
</code></pre>
<h3 id="思路与解答-4">思路与解答</h3>
<p>  这道题第一想法是递归，假设经过i次移动到达位置j的方法有n[i][j]，每一步只有左右移动或不动，反映为j-1或者j+1或j，因此经过i次移动到达位置j的方法可以拆为①经过i-1次移动到达位置j-1；②经过i-1次移动到达位置j+1；③经过i-1次移动到达位置j。递推公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>n</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>n</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>n</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">n[i][j]=n[i-1][j-1]+n[i-1][j+1]+n[i-1][j]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>
<p>  初始状态n[0][0]=1（由n[1][0]=1可以倒推），限制为j-1不能小于0且j+1必须小于arrLen。</p>
<pre><code class="language-python">class Solution:
    def numWays(self, steps: int, arrLen: int) -&gt; int:
       '''分析可知steps内最远也只能到达steps位置，因此再长的序列其实没有意义，取两者较小的一个即可'''
        arrLen = min(arrLen, steps + 1)
        n = [[0] * arrLen for i in range(steps + 1)]
        n[0][0] = 1
        for i in range(1, steps + 1):
            for j in range(arrLen):
                for k in [-1, 0, 1]:
                    #限制条件的判断，坐标必须在0到arrLen-1之内
                    if 0 &lt;= j - k &lt; arrLen:
                        n[i][j] += n[i - 1][j - k]
        return n[steps][0] % (10**9 + 7)
</code></pre>
<h2 id="1604警告一小时内使用相同员工卡大于等于三次的人">1604.警告一小时内使用相同员工卡大于等于三次的人</h2>
<h3 id="题目描述-5">题目描述</h3>
<p>  每当一个员工使用一次他的员工卡，安保系统会记录下员工的名字和使用时间。如果一个员工在一小时时间内使用员工卡的次数大于等于三次，这个系统会自动发布一个 警告 。给你字符串数组keyName 和 keyTime ，其中 [keyName[i], keyTime[i]] 对应一个人的名字和他在 某一天 内使用员工卡的时间。使用时间的格式是 24小时制 ，形如 &quot;HH:MM&quot; ，比方说 &quot;23:51&quot; 和 &quot;09:49&quot; 。请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。请注意 &quot;10:00&quot; - &quot;11:00&quot; 视为一个小时时间范围内，而 &quot;23:51&quot; - &quot;00:10&quot; 不被视为一小时内，因为系统记录的是某一天内的使用情况。</p>
<h3 id="示例-5">示例</h3>
<pre><code>输入：keyName = [&quot;daniel&quot;,&quot;daniel&quot;,&quot;daniel&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;,&quot;luis&quot;], keyTime = [&quot;10:00&quot;,&quot;10:40&quot;,&quot;11:00&quot;,&quot;09:00&quot;,&quot;11:00&quot;,&quot;13:00&quot;,&quot;15:00&quot;]
输出：[&quot;daniel&quot;]
解释：&quot;daniel&quot; 在一小时内使用了 3 次员工卡（&quot;10:00&quot;，&quot;10:40&quot;，&quot;11:00&quot;）。
</code></pre>
<h3 id="思路与解答-5">思路与解答</h3>
<p>  首先写一个judge(name)函数，用来判断name这个人是否在一小时内用了三次卡，具体写法是先从keyTime中选择name对应的全部时间点存为time列表，如果time长度小于3直接不用判断return 0，如果time长度大于3，首先将time排序，然后从time[0]开始遍历到time[倒数第三个]，判断规则是：如果time[i]加上一小时超过了time[i+2]，就break跳出循环并return name。之后只需要从set(keyName)中一个个选择name，套用这个函数，把不是return 0的name给记录最后排序输出即可。如下：</p>
<pre><code class="language-python">class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -&gt; List[str]:
        def judge(name):
            time=[]
            result = ''
            for i in range(len(keyName)):
                if keyName[i]==name:
                    time.append(keyTime[i])
            if len(time)&gt;=3:
                time.sort()
                for i in range(len(time)-2):
                    newtime = str(int(time[i][0:2])+1)+time[i][2:]
                    if len(newtime)&lt;5:
                        newtime = '0'+newtime
                    if newtime&gt;=time[i+2]:
                        result=name
                        break
            return result
        answer = []
        for i in set(keyName):
            if judge(i)!='':
                answer.append(judge(i))
        answer.sort()
        return answer
</code></pre>
<p>  然而，非常遗憾，提交之后显示运行超时Orz，说明复杂度太高了。看了下题解有个老哥用了字典连接name和对应的time，并且把时间统一转为分钟min进行比较，个人觉得不错，如下：</p>
<pre><code class="language-python">class Solution:
    def alertNames(self, keyName: List[str], keyTime: List[str]) -&gt; List[str]:
        hashamp = {}
        for i in range(len(keyName)):
            time = keyTime[i].split(&quot;:&quot;)
            time = int(time[0])*60 + int(time[1])
            if keyName[i] not in hashamp:
                hashamp[keyName[i]] = [time]
            else:
                hashamp[keyName[i]].append(time)
        for name in hashamp.keys():
            hashamp[name].sort()
        lst = []
        for name in hashamp.keys():
            '''这里貌似有点小瑕疵，默认了hashamp[name]的长度都是大于2的，应该加个if判断不然会出现index错误'''
            for i in range(len(hashamp[name])-2):
                if 0 &lt; hashamp[name][i+2]-hashamp[name][i] &lt;= 60:
                    lst.append(name)
                    break
        lst.sort()
        return lst
</code></pre>
<h2 id="150逆波兰表达式求值">150.逆波兰表达式求值</h2>
<h3 id="题目描述-6">题目描述</h3>
<p>  根据 逆波兰表示法，求表达式的值。有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。注：逆波兰表达法又叫后缀表达法，详情请自行百度。  <strong>说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</strong></p>
<h3 id="示例-6">示例</h3>
<pre><code>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre>
<h3 id="思路与解答-6">思路与解答</h3>
<p>  首先要思考后缀表达式的计算顺序，第一个计算的三元子式一定是[符号,数字,数字]这种类型，于是很自然地我想到了递归的方法，并且表达式最后一个一定是运算符，通过运算顺序不断简化后缀表达式，最后停止条件就是表达式长度变为3，此时return 结果，其余情况return 本身。代码如下：</p>
<pre><code class="language-python">class Solution:
    def evalRPN(self, tokens: List[str]) -&gt; int:
        #逆序储存方便使用
        inv_tokens = tokens[::-1]
        #核心函数，i表示此时在索引i处
        def getresult(tlist,i):
            #表达式长度为1说明就是结果
            if len(tlist)==1:
                return int(tlist[i])
            #如果索引i后两位仍有运算符则右移索引
            elif tlist[i+1] in ['+','-','*','/'] or tlist[i+2] in ['+','-','*','/']:
                return getresult(tlist, i+1)
            #如果tlist长度不为3，计算一个子式并化简得到新tlist
            elif len(tlist)!=3:
                tlist = tlist[0:i]+[str(int(eval(tlist[i+2]+tlist[i]+tlist[i+1])))]+tlist[i+3:]
                return getresult(tlist, i-2)
            #上面三个都不执行说明已经变为最简，直接计算出结果
            else:
                result = int(eval(tlist[i+2]+tlist[i]+tlist[i+1]))
                return result
        return getresult(inv_tokens,0)
</code></pre>
<p>  递归便于人理解但对计算机来说运行会比较慢（还好没有超时，姑且算做对了），题解里有一种比较简便的方法：使用一个栈存储操作数，从左到右遍历逆波兰表达式，如果遇到操作数，则将操作数入栈；如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。</p>
<pre><code class="language-python">class Solution:
    def evalRPN(self, tokens: List[str]) -&gt; int:
        op_to_binary_fn = {
            &quot;+&quot;: add,
            &quot;-&quot;: sub,
            &quot;*&quot;: mul,
            &quot;/&quot;: lambda x, y: int(x / y),   # 需要注意 python 中负数除法的表现与题目不一致
        }
        stack = list()
        for token in tokens:
            try:
                num = int(token)
            except ValueError:
                num2 = stack.pop()
                num1 = stack.pop()
                num = op_to_binary_fn[token](num1, num2)
            finally:
                stack.append(num)  
        return stack[0]
</code></pre>
<h2 id="152乘积最大子数组">152.乘积最大子数组</h2>
<h3 id="题目描述-7">题目描述</h3>
<p>  给你一个整数数组 nums ，请你找出数组中乘积最大的<strong>连续</strong>子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<h3 id="示例-7">示例</h3>
<pre><code>输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
</code></pre>
<h3 id="思路与解答-7">思路与解答</h3>
<p>  从左到右遍历，明确更新最大乘积的规则，由于有负数出现的可能，最大乘积可能*负数直接变成最小乘积，而最小乘积也可能*负数直接变成最大乘积，所以应该在遍历时同时更新最大和最小乘积，并且每次将更新后的最大乘积和历史最大乘积对比，取最大值更新为历史最大乘积，最后遍历完return 历史最大乘积即可，注意判定规则，最大值=max（最大值*下一个元素，最大值，最小值*下一个元素），最小值的更新规则同理：</p>
<pre><code class="language-python">class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        if len(nums)==1:
            result = nums[0]
        else:
            #初始最大、最小、历史最大均设为nums[0]
            maxnums = nums[0]
            minnums = nums[0]
            result = nums[0]
            for i in range(1,len(nums)):
                mn = maxnums
                maxnums = max(maxnums*nums[i],nums[i],minnums*nums[i])
                minnums = min(mn*nums[i],nums[i],minnums*nums[i])
                result = max(result,maxnums)
        return result
</code></pre>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://wangykonne.github.io/post/sql-shi-zhan-chi-xu-geng-xin/" class="post-title gt-a-link">
                    SQL实战（持续更新）
                </a>
            </div>
        

        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'aHb7wrt4LdY1y2xNnPnv8Bdf-9Nh9j0Va',
		appKey: '3ND7IFEdq0etn28alvpNtWLk',
		avatar: 'mp',
		pageSize: 5,
		recordIp: false,
		placeholder: 'Just Go Go',
		visitor: false,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">日近长安远</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://wangykonne.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
