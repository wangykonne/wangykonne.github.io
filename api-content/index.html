{"posts":[{"title":"SQL学习笔记（五）","content":" 学习用书：SQL基础教程（Mick著） 数据库：MySQL 数据库可视化软件：SQLyog 第四章：数据更新 4.1 数据的插入 4.1.1 INSERT语句的基本用法 在第一章创建数据库CREATE DATABASE，创建表CREATE TABLE时，运用了INSERT向表中插入数据，但当时没有介绍INSERT的详细使用方法。INSERT语句的基本用法如下，下面的ProductIns是为了这一节学习创建的空表，列和Product一样： #创建学习用空表ProductIns CREATE TABLE ProductIns (product_id CHAR(4) NOT NULL, product_name VARCHAR(100) NOT NULL, product_type VARCHAR(32) NOT NULL, sale_price INTEGER DEFAULT 0, purchase_price INTEGER , regist_date DATE , PRIMARY KEY(product_id)); #向表中插入一列数据 INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES ('0001', 'T恤衫','衣服', 1000, 500, '2009-09-20'); 上面显示的INSERT的用法是最基础的，即INSERT INTO 表名 (列名) VALUES (值)，注意值的个数要和列名的个数一致。当同时插入多行数据时，有简便的语法形式，如下： #多行INSERT(Oracle除外) INSERT INTO ProductIns VALUES ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'), ('0003', '运动T恤', '衣服', 4000, 2800, NULL), ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20'); #Oracle的多行INSERT INSERT ALL INTO ProductIns VALUES ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11') INTO ProductIns VALUES ('0003', '运动T恤', '衣服', 4000, 2800, NULL) INTO ProductIns VALUES ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20') SELECT * FROM DUAL; 上面的代码第一段比较好理解，就是省略了一些结构性的语句。第二段中的DUAL表是Oracle特有的一种临时表，SELECT * FROM DUAL并没有什么实际意义。 4.1.2 列清单的省略 上一节的代码中，其实已经采用了省略列清单的语句进行INSERT，这种语法很好理解，SQL会将值从左到右赋给从左到右的每一个列。所以在INSERT时，只要注意输入值的顺序就可以省略列清单。 4.1.3 插入NULL 想要在表中插入NULL值很简单，直接把值写为NULL即可，唯一要注意的就是列是否有NOT NULL的限制。 4.1.4 插入默认值 还可以在表中插入默认值，首先要在CREATE TABLE语句时设置DEFAULT约束来设置默认值。如第一节的代码中设置了sale_price的默认值为0。插入默认值的方法分为两种，显式和隐式： #显式方法插入默认值 INSERT INTO ProductIns VALUES ('0007', '擦菜板', '厨房用具', DEFAULT, 790, '2209-04-28'); 显式方法直接把值写为DEFAULT即可，隐式方法只要同时省略列和对应的值即可将该列设置为默认值，如下在列清单中省略sale_price在值清单中省略其值，也可设置默认值： #隐式方法插入默认值 INSERT INTO ProductIns (product_id, product_name, product_type, purchase_price, regist_date) VALUES ('0007', '擦菜板', '厨房用具', 790, '2209-04-28'); 实际使用中，显式方法用的更多，因为代码清晰简洁。最后有一点，不管用显式方法将没有设置默认值的列设置为DEFAULT还是用隐式方法胜率了没有设置默认值的列，都会将这列的值设置为NULL，如果恰好这列又有NOT NULL的限制则会出现错误。 4.1.5 从其他表中复制数据 下面来学习从其他表中复制数据，下面先创建一个和Product表结构完全一样的表ProductCopy： #创建学习用表ProductCopy CREATE TABLE ProductCopy (product_id CHAR(4) NOT NULL, product_name VARCHAR(100) NOT NULL, product_type VARCHAR(32) NOT NULL, sale_price INTEGER , purchase_price INTEGER , regist_date DATE , PRIMARY KEY (product_id)); 下面把Product的表直接复制到ProductCopy中，语句结构为INSERT INTO...SELECT...FROM...： #从Product表中复制所有数据到ProductCopy INSERT INTO ProductCopy (product_id, product_name, product_type, sale_price, purchase_price, regist_date) SELECT product_id, product_name, product_type,sale_price, purchase_price, regist_date FROM Product; 上面的代码用到了SELECT语句，事实上这个SELECT语句还可以使用WHERE子句或者GROUP BY子句和聚合函数，可以在复制数据时加入很多限制条件，例如，想在Product表中按product_type分类并计算sale_price和purchase_price的总值并将这三列数据复制到表Product_type中： #先创建一个Product_type表 CREATE TABLE Product_type (product_type VARCHAR(32) NOT NULL, sum_sale_price INTEGER , sum_purchase_price INTEGER , PRIMARY KEY(product_type)); #在Product表中按product_type分类并计算sale_price和purchase_price的总值并将这三列数据复制到表Product_type中 INSERT INTO Product_type (product_type, sum_sale_price, sum_purchase_price) SELECT product_type, SUM(sale_price), SUM(purchase_price) FROM Product GROUP BY product_type; 其实上面的代码也可以省略列清单，只要对应好值的顺序即可。最后，INSERT中的SELECT语句可以使用几乎所有已学的语法子句和函数，除了ORDER BY，排序语句在INSERT的SELECT中不起作用。 4.2 数据的删除 4.2.1 DROP TABLE语句和DELETE语句 这两个语句在第一章其实都用过，DROP TABLE会将表完全删除，再想用只能重新创建表；而DELETE会将表的所有数据删除但会保留表本身，故可以直接重新插入数据。这是它们的主要区别。 4.2.2 DELETE语句的基本语法 单独一个DELETE的用法很有限，只能删除表中所有的数据： #清空表Product DELETE FROM Product; DELETE语句要接FROM而不是TABLE，不要和DROP TABLE记混淆了。同时DELETE的删除对象是行，故不能进行只删除某些列的操作，并且DELETE * FROM xx也是错误的用法。 4.2.3 指定删除对象的DELETE语句 DELETE以行为对象，所以可以像SELECT一样使用WHERE语句进行指定条件，例如想删除Product表中sale_price大于等于4000的数据： #删除Product表中sale_price大于等于4000的数据 DELETE FROM Product WHERE sale_price &gt;= 4000; 与SELECT语句不同的是，DELETE语句不能使用GROUP BY、HAVING和ORDER BY这三种子句，只能使用WHERE语句，而WHERE语句中又不能使用聚合函数，所以DELETE也与聚合函数无关了，综上，DELETE语句的使用方法还是很简单且有限的。 4.3 数据的更新 4.3.1 UPDATE语句的基本语法 如果在INSERT语句插入数据后，有时还想更改数据，此时并不需要将数据完全删除，而可以使用UPDATE直接对数据进行更新，UPDATE的基本语法如下，UPDATE 表名 SET 列名=表达式;如下例子，将regist_date全部更新为'2009-10-10': #将regist_date全部更新为'2009-10-10' UPDATE Product SET regist_date = '2009-10-10'; 4.3.2 指定条件的UPDATE语句 同DETELE一样，UPDATE也有指定条件的用法，不然只有上面这种用法实在是太蠢了。指定条件同样使用了WHERE语句，如下将商品种类为厨房用具的记录的销售单价更新为原来的十倍： #将商品种类为厨房用具的记录的销售单价更新为原来的十倍 UPDATE Product SET sale_price = sale_price*10 WHERE product_type = '厨房用具'; 最后，UPDATE也可以将列的值更新为NULL，比较简单就不写例子了。 4.3.3 多列更新 如果要进行多列更新且这些UPDATE语句很相似时怎么办呢？如下，一条一条的输入： #将商品种类为厨房用具的记录的销售单价更新为原来的十倍 UPDATE Product SET sale_price = sale_price*10 WHERE product_type = '厨房用具'; #再将商品种类为厨房用具的记录的进货单价更新为原来的一半 UPDATE Product SET purchase_price = purchase_price/2 WHERE product_type = '厨房用具'; 上面的方法繁琐又增加了阅读量，可以合并为一条UPDATE语句执行，具体有两种方法： #多列更新方法①，使用逗号分割 UPDATE Product SET sale_price = sale_price*10, purchase_price = purchase_price/2 WHERE product_type = '厨房用具'; #多列更新方法②，将列用()清单化，方法②只适合PostgreSQL和DB2 UPDATE Product SET (sale_price, purchase_price) = (sale_price*10, purchase_price/2) WHERE product_type = '厨房用具'; 上面两种方法的结果是一样的，但第二种方法只适用于PostgreSQL和DB2系统，所以一般还是第一种方法最常用。 今天学习完毕，明天完结第四章最后一节（比较长），有时间再学点第五章。 ","link":"https://wangykonne.github.io/post/sql-xue-xi-bi-ji-wu/"},{"title":"SQL学习笔记（四）","content":" 学习用书：SQL基础教程（Mick著） 数据库：MySQL 数据库可视化软件：SQLyog 第三章：聚合与排序 3.3 为聚合结果指定条件 3.3.1 HAVING子句 昨天最后说到了一个例子，如果想取出GROUP BY分组后COUNT数恰好为2的组怎么办呢？WHERE语句不能使用聚合函数，所以这时就要采用HAVING子句了。下面是昨天的问题的解决方法： #按product_type分组并取出COUNT数恰好为2的类别 SELECT product_type, COUNT(*) FROM Product GROUP BY product_type HAVING COUNT(*) = 2; HAVING的语法为：HAVING语句写在GROUP BY语句之后，且语句的执行顺序也在GROUP BY之后。目前学过的所有语句的书写顺序暂时为： SELECT→FROM→WHERE→GROUP BY→HAVING 同样，HAVING语句也接受其他类型的聚合函数，例如想按product_type分组并取出sale_price的平均值大于等于2500的商品并记录其商品种类和avg值： #按product_type分组并取出sale_price的平均值大于等于2500的商品并记录其商品种类和avg值 SELECT product_type, AVG(sale_price) AS avg FROM Product GROUP BY product_type HAVING AVG(sale_price) &gt;= 2500; 3.3.2 HAVING子句的构成要素 HAVING子句和包含GROUP BY的SELECT子句一样，对子句内的元素有一定限制，限制也是完全一样的，即HAVING子句内能使用的元素只有①常数；②聚合函数；③GROUP BY子句中出现的列名。下面是一个会出现错误的例子： #错误示范① SELECT product_type, COUNT(*) FROM Product GROUP BY product_type HAVING product_name = '圆珠笔'; 3.3.3 与HAVING语句相比，更适合写在WHERE中的条件 也许有人已经发现了，当条件限制不是聚合函数时，HAVING和WHERE的功能似乎重合了。下面来看两个例子，均表示按product_type分类并选择product_type为衣服的类别并查询其COUNT，但一个使用HAVING，一个使用WHERE： #按product_type分类并选择product_type为衣服的类别并查询其COUNT，使用HAVING SELECT product_type, COUNT(*) FROM Product GROUP BY product_type HAVING product_type = '衣服'; #按product_type分类并选择product_type为衣服的类别并查询其COUNT，使用HAVING SELECT product_type, COUNT(*) FROM Product WHERE product_type = '衣服' GROUP BY product_type; 上面两段代码的结果是完全一样的，确实在不涉及聚合函数的限制条件时使用HAVING和WHERE是等价的，但书上建议使用WHERE，因为WHERE语句的执行速度比HAVING快。总结一下就是，当限制条件涉及使用聚合函数时使用HAVING，其他情况均使用WHERE。 3.4 对查询结果进行排序 3.4.1 ORDER BY子句 目前我们已经学习了各种的查询、限制条件、聚合函数、分组方法，下面来学习对查询结果进行排序。在SQL中，使用ORDER BY子句就可以对查询结果进行排序，很简单。下面看一个例子，例如按销售单价升序查询product_id,product_name,sale_price,purchase_price： #按销售单价升序查询product_id,product_name,sale_price,purchase_price SELECT product_id, product_name, sale_price, purchase_price FROM Product ORDER BY sale_price; 不论什么情况，ORDER BY子句都是写在SELECT语句的末尾（limit除外），同时执行顺序里ORDER BY也是在结果即将输出时进行排序。所以到目前为止，我们所学的所有子句的书写顺序暂时为： SELECT→FROM→WHERE→GROUP BY→HAVING→ORDER BY 3.4.2 指定升序或者降序 默认情况下ORDER BY子句是升序操作，可以在列名后加DESC关键字进行降序操作，当然升序也可以使用ASC关键字。下面试试上节一样的例子，这次采用降序排列： #按销售单价降序查询product_id,product_name,sale_price,purchase_price SELECT product_id, product_name, sale_price, purchase_price FROM Product ORDER BY sale_price DESC; 3.4.3 指定多个排序键 如果想指定多个排序规则，例如上面的例子中sale_price相等的商品可以再按照另一个排序键进行排序。同时ASC和DESC关键字都是以列为单位的，所以可以自定义使用来制定多种多样的排序规则。例如，按销售单价升序再按商品编号降序查询product_id,product_name,sale_price,purchase_price： #按销售单价升序再按商品编号降序查询product_id,product_name,sale_price,purchase_price SELECT product_id, product_name, sale_price, purchase_price FROM Product ORDER BY sale_price ASC, product_id DESC; 3.4.4 NULL的顺序 对于含有NULL值的列会怎么样进行排序呢，下面看一个例子，对进货单价升序查询product_id,product_name,sale_price,purchase_price： #按进货单价升序查询product_id,product_name,sale_price,purchase_price SELECT product_id, product_name, sale_price, purchase_price FROM Product ORDER BY purchase_price; 在我自己的MySQL中，结果的NULL值被全部放在了最开头的部分，但不是表示NULL比所有值都小。前面说过NULL不能进行四则运算也不能进行排序，所以所有的RDBMS都会规定在排序中统一把NULL放在最开头或者结尾的地方，具体是开头还是结尾视不同的RDBMS定，有的RDBMS还能指定开头或者结尾。至少在MySQL中是统一放在开头处。 3.4.5 在排序键中使用显示用的列别名 前面说过在GROUP BY子句中不能使用列的别名，但在ORDER BY子句中可以使用列的别名： #按销售单价升序再按商品编号降序查询product_id,product_name,sale_price,purchase_price，并把product_id改为id，sale_price改为sp SELECT product_id AS id, product_name, sale_price AS sp, purchase_price FROM Product ORDER BY sp ASC, id DESC; 上面代码和上上节的代码查询结果完全相同（除了别名）。ORDER BY子句可以使用别名的原因和语句的执行顺序有关，到目前为止，学过的所有子句的执行顺序暂时为： FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY 可以看到ORDER BY位于SELECT之后，所以在SELECT写的别名可以被ORDER BY识别，而GROUP BY执行于SELECT之前所以不能识别SELECT写的别名。事实上所有执行早于SELECT的子句都不能使用别名。 3.4.6 ORDER BY子句中可以使用的列 ORDER BY子句内的元素使用范围比较宽泛，甚至在SELECT中没出现的列也可以作为ORDER BY子句的排序键： #按product_id升序查询product_name,sale_price,purchase_price SELECT product_name, sale_price, purchase_price FROM Product ORDER BY product_id; 上面的语句也可以执行，不过因为没有SELECT product_id，排序的效果会看不见所以不推荐这种方法。除此之外，ORDER BY还可以使用聚合函数： #按product_type分类并查询其COUNT，最后再按COUNT进行升序排序 SELECT product_type, COUNT(*) FROM Product GROUP BY product_type ORDER BY COUNT(*); 今天将第三章完结了，明天开始第四章数据更新的学习。 ","link":"https://wangykonne.github.io/post/sql-xue-xi-bi-ji-si/"},{"title":"SQL学习笔记（三）","content":" 学习用书：SQL基础教程（Mick著） 数据库：MySQL 数据库可视化软件：SQLyog 第二章：查询基础 2.3 逻辑运算符 2.3.1 NOT运算符 NOT运算符比较好理解，就是表示&quot;非&quot;的意思，使用范围比不等号&lt;&gt;要广，例如想要选择销售单价小于1000的商品时，就可以用NOT语句： #使用NOT查询sale_price小于1000的行的product_name,product_type,sale_price值 SELECT product_name, product_type, sale_price FROM Product WHERE NOT sale_price &gt;= 1000; 虽然直接用&lt;1000可以不用使用NOT，但上面例子只是展示一下用法，NOT语句在复杂的语法中会发挥它的作用。 2.3.2 AND运算符和OR运算符 实际生活中，往往查询中不止一个限制条件，此时就可以使用AND和OR运算符，分别表示且、或的概念。例如，想查询商品种类为厨房用品且销售单价大于等于3000的商品，可以使用AND： #查询product_type为'厨房用具'且sale_price不小于3000的行的product_name,purchase_price SELECT product_name, purchase_price FROM Product WHERE product_type = '厨房用具' AND sale_price &gt;= 3000; 想查询商品种类为厨房用品或者销售单价大于等于3000的商品，可以使用OR： #查询product_type为'厨房用具'或者sale_price不小于3000的行的product_name,purchase_price SELECT product_name, purchase_price FROM Product WHERE product_type = '厨房用具' OR sale_price &gt;= 3000; 2.3.3 通过括号强化处理 需要注意的是，AND运算符的优先级高于OR运算符，如果在混合使用中，可能会引起歧义，这时最好使用括号进行处理。例如想要查询商品种类为办公用品，并且，登记日期为2009-9-11或2009-9-20的商品： #查询product_type为'办公用品'且regist_date为'2009-09-11'或'2009-09-20'的行的product_name,product_type,regist_date SELECT product_name, product_type, regist_date FROM Product WHERE product_type = '办公用品' AND (regist_date = '2009-09-11' OR regist_date = '2009-09-20'); 上面的语句中，如果把括号去掉，会返回不一样的结果，因为AND的运算优先级高于OR，SQL会理解为&quot;product_type = '办公用品' AND regist_date = '2009-09-11'&quot; OR &quot;regist_date = '2009-09-20'&quot;。所以在混合使用时要注意使用括号。 2.3.4 含有NULL时的真值 在SQL中，逻辑运算符的结果除了TRUE和FALSE外，还有一个UNKNOWN，表示不确定值。即NULL值在和真假值进行AND和OR运算时，会产生UNKNOWN值，具体运算规则比较简单，直接想想就懂了。 第三章：聚合与排序 3.1 对表进行聚合排序 3.1.1 聚合函数 通过SQL对数据某些操作时需要使用函数。下面是5个基本的函数： COUNT：记录表中的行数（数据数） SUM：计算表中数据的各列的数据的总值。 AVG：计算表中数据的各列的平均值。 MAX：计算表中数据的各列的最大值。 MIN：计算表中数据的各列的最小值。 3.1.2 计算表中数据的行数 使用COUNT函数可以计算表中数据的行数，例如计算表中数据一共有多少行： #查询全部数据的行数 SELECT COUNT(*) FROM Product; 3.1.3 计算除NULL值以外的数据的行数 例如purchase_price列中含有NULL值，所以使用COUNT进行查询时，会返回非NULL值的行数： #查询purchase_price列中非NULL的行数 SELECT COUNT(purchase_price) FROM Product; 需要注意一个特殊情况，例如一个只有一列的表，其三行数据均为NULL，则用COUNT(*)查询时会返回3，但使用COUNT(列名)查询时会返回0！原因很简单，就是COUNT函数的原理问题，就不多介绍了。 3.1.4 计算合计值 使用SUM函数可以得到指定列的数据总值，例如求sale_price,purchase_price列的数据总和： #查询sale_price,purchase_price列的数据总和 SELECT SUM(sale_price), SUM(purchase_price) FROM Product; 需要注意的是，purchase_price中含有NULL值，为什么还会返回出计算的正确结果呢，按照昨天的学习NULL值进行四则运算一定会得到NULL值。原因是所有的聚合函数在以列名为参数时会自动先把NULL值的行排除在外，所以即使列内有NULL值也能使用聚合函数得到对应的结果。 3.1.5 计算平均值 使用AVG函数可以计算指定列的数据的平均值，例如求sale_price,purchase_price列的数据平均值： #查询sale_price,purchase_price列的数据平均值 SELECT AVG(sale_price), AVG(purchase_price) FROM Product; 上面说到，聚合函数以列名为参数时会忽略NULL值，所以此时计算平均数的分母也会发生变化，例如purchase_price中非NULL值为6行，所以平均值计算会除以6而不是除以8。当然也有方法把NULL视为0然后除以8计算平均值，这种方法会在第六章介绍。 3.1.6 计算最大值和最小值 使用MIN和MAX可以得到指定列的数据最大值和最小值，例如求sale_price的最小值和purchase_price的最大值： #查询sale_price的最小值和purchase_price的最大值 SELECT MIN(sale_price), MAX(purchase_price) FROM Product; 需要注意的是，MAX/MIN函数和SUM/AVG函数有一点不同，SUM/AVG函数只能对数值类型的列使用，但MAX/MIN函数原则上可以适用于任何类型的数据列，例如如果对字符串类型则会按字典排序的方法选择最大值和最小值： #查询登记日期的最大值和最小值 SELECT MIN(regist_date), MAX(regist_date) FROM Product; 3.1.7 使用聚合函数删除重复值 聚合函数和DISTINCT函数结合使用，如想知道一个列有几种不同的值： #查询product_type总共有多少种不同的取值 SELECT COUNT(DISTINCT product_type) FROM Product; 其他聚合函数和DISTINCT的用法类似，注意DISTINCT要放在聚合函数的括号内。 3.2 对表进行分组 3.2.1 GROUP BY子句 前面所学的各种语句都是对表中的所有数据进行的汇总处理。而使用GROUP BY语句可以将表分为多个组再进行汇总处理，例如，想按照商品种类来统计一下数据的行数： #按product_type查询数据的行数 SELECT product_type, COUNT(*) FROM Product GROUP BY product_type; GROUP BY子句中指定的列成为聚合键或者分组列，如上product_type有三种不同的类型故最后查询的结果分别为这三种类型的各自行数。同样GROUP BY也可以通过逗号分割指定多列。最后GROUP BY子句的书写位置有固定的规则，一定要写在FROM语句后面，而如果还有WHERE语句那就要在WHERE语句之后。目前学习的语法顺序暂定为： SELECT➡FROM➡WHERE➡GROUP BY 3.2.2 聚合键中包含NULL的情况 purchase_price中含有两个NULL，所以我们用它做GROUP BY实验，看会得到怎样的结果： #按照purchase_price统计数据行数 SELECT purchase_price, COUNT(*) FROM Product GROUP BY purchase_price; 上面的结果会将NULL也视为一个类别，即不确定，会在表中以空行的形式展现出来。 3.2.3 同时使用WHERE语句和GROUP BY语句 同时使用WHERE和GROUP BY子句时，会先用WHERE语句对数据进行过滤，再按照GROUP BY进行汇总处理，例如查询商品类别为衣服的数据并按照进货价格分类，显示其进货价格和数据量： #查询商品类别为衣服的数据并按照进货价格分类，显示其进货价格和数据量： SELECT purchase_price, COUNT(*) FROM Product WHERE product_type = '衣服' GROUP BY purchase_price; 上面代码的执行顺序为：FROM→WHERE→GROUP BY→SELECT 3.2.4 与聚合函数和GROUP BY子句有关的常见错误 常见错误①：在SELECT子句中书写了不在聚合键中的列。 在使用COUNT这样的聚合函数时，SELECT子句的元素有很强的限制，只能存在以下三种成分：①常数，②聚合函数，③GROUP BY子句中指定的列名。下面给出一个错误的例子： #常见错误①的例子 SELECT product_name, purchase_price, COUNT(*) FROM Product GROUP BY purchase_price; 上面的代码中，SELECT语句的product_name没有包含在聚合键GROUP BY中，会出现错误。不支持这种语法的原因其实很好理解，因为按照GROUP BY分类后，类别数肯定是小于等于没分类的product_nam的行数的，这样表格就不是一对一的了，会出现问题，所以这种语法被禁止。 常见错误②：在GROUP BY子句中写了列的别名。 前面说过用SELECT AS 可以给列取别名，但如果在GROUP BY中使用这个别名来调用列就会出现错误： #常见错误②的例子 SELECT purchase_price AS pp, COUNT(*) FROM Product GROUP BY pp; 注意：上面的代码并非在所有RDBMS中都会产生错误，在PostgreSQL和MySQL中上面的语句是可以执行的，而在其他的RDBMS中则不能执行。在一些RDBMS中上面语句不能执行的原因很简单，就和之前说的语句执行顺序有关，GROUP BY会先于SELECT语句执行，故在SELECT中的别名不会被GROUP BY识别。尽管这种错误跟不同软件有关，但最好还是不要用这种语法了。 常见错误③：在WHERE语句中使用聚合函数。 先看一个正确的例子，按照商品类别进行分类： #按照商品类别进行分类并查询各类别的行数 SELECT product_type, COUNT(*) FROM Product GROUP BY product_type; 上面的代码的结果会返回三行数据，其中衣服和办公用品的COUNT都是2，厨房用具的COUNT是4。此时如果我们想查询COUNT数恰好为2的数据该怎么办呢？下面是一个错误的例子： #常见错误③的例子 SELECT product_type, COUNT(*) FROM Product WHERE COUNT(*) = 2 GROUP BY product_type; 理所当然地在WHERE中加入COUNT=2的选择条件是不行的，因为WHERE语句中不能使用聚合函数，要达到上面这个问题的目的需要使用HAVING子句。HAVING语句会在明天的3.3节中介绍。计划明天将第三章完结并做课后习题。 ","link":"https://wangykonne.github.io/post/sql-xue-xi-bi-ji-san/"},{"title":"SQL学习笔记（二）","content":" 学习用书：SQL基础教程（Mick著） 数据库：MySQL 数据库可视化软件：SQLyog 第二章：查询基础 2.1 SELECT语句基础 2.1.1 列的查询 从表中选取数据需要使用SELECT语句。SELECT语句的基本语法为： SELECT &lt;列名1&gt;,&lt;列名2&gt;... FROM &lt;表名&gt;; 这个语法非常简单，用昨天的Product表做个小例子： #查询Product表中的product_id,product_name,product_price三列的所有数据 SELECT product_id, product_name, purchase_price FROM Product; 最后，查询结果中列的顺序和SELECT子句的顺序相同，且不同列要用,隔开。 2.1.2 查询出表中所有的列 想要查询所有的列时，不需要按上面的方法把所有的列名都写出来，只需要用*代表所有的列： #查询Product中所有的列的所有数据 SELECT * FROM Product; 查询所有列时结果的列的顺序和创建表的列的顺序一致。 2.1.3 为列设置别名 SQL可以在SELECT中给列设置别名，语法和Python中的import as差不多，运用AS语句： #查询Product表中的product_id,product_name,product_price三列的所有数据，并将结果列名设置为id,name,price SELECT product_id AS id, product_name AS name, purchase_price AS price FROM Product; 别名也可以使用中文，不过要用双引号&quot;括起来，注意单引号'是不行的。 #查询Product表中的product_id,product_name,product_price三列的所有数据，并将结果列名设置为商品编号，商品名称，进货单价 SELECT product_id AS &quot;商品编号&quot;, product_name AS &quot;商品名称&quot;, purchase_price AS &quot;进货单价&quot; FROM Product; 2.1.4 常数的查询 SELECT的子句不仅可以书写列名，还可以书写常数，如下： #查询Product表中product_id,product_name列的所有数据，并在前面加入三个常数列，分别为商品，38，2009-02-24，别名为string,number,date SELECT '商品' AS string, 38 AS number, '2009-02-24' AS date, product_id, product_name FROM Product; 上面代码的结果会在product_id,product_name列前创建三个列名为string,number,date的列，这三个列的所有数据都为常数，分别对应'商品'，38，'2009-02-24'。 2.1.5 从结果中删除重复行 Product_type表示商品的种类，在表Product中存在一些重复的product_type，如果想知道表中一共有几种product_type时，可以在SELECT语句的子句中使用DISTINCT语句实现： #删除product_type列中的重复数据 SELECT DISTINCT product_type FROM Product; 在使用DISTINCT时，NULL值也会被看成一类，故不同行的NULL值也会被合并为一类。DISTINCT也可以在多列之前使用，此时会将多个列的数据进行组合，将重复的数据组合合并为一类。例如，下面的代码会选出7个数据： #删除product_type,regist_date列中的共同重复数据 SELECT DISTINCT product_type, regist_date FROM Product; 注意，DISTINCT关键字只能用在第一个列名前面，即不能写成product_type, DISTINCT regist_date。 2.1.6 根据WHERE语句来选择记录 前面的学习中，SELECT都是把所有数据全部选取出来，实际应用中，大部分情况是要选择满足一定特定条件的数据。使用WHERE语句可以指定查询的条件，例如：选取product_type为衣服的所有数据并输出它们的product_name： #选取product_type为衣服的所有数据并输出它们的product_name SELECT product_name, product_type FROM Product WHERE product_type = '衣服'; 上面代码的执行顺序为：首先WHERE语句先进行筛选出符合条件的所有行，再由SELECT选择对应的列。SQL的子句的书写顺序是固定的不能随意更改，WHERE子句必须紧跟在FROM子句之后。 2.1.7 注释的书写方法 和Python一样，SQL的注释分为一行注释和多行注释两种。 一行注释：书写在&quot;-- &quot;之后，只能写在同一行。 多行注释：书写在&quot;/*&quot;和&quot;*/&quot;之间，可以跨多行。 #注释的使用方法 #一行注释 -- 本SELECT语句会从结果中删除重复行 SELECT DISTINCT product_type, regist_date FROM Product; #多行注释 /* 本SELECT语句， 会从结果中删除重复行 */ SELECT DISTINCT product_type, regist_date FROM Product; 2.2 算术运算符和比较运算符 2.2.1 算术运算符 先看一个例子来理解怎么在SELECT中加入算术运算符： #选取product_name,sale_price列和sale_price的两倍命名为sale_price_x2 SELECT product_name, sale_price, sale_price*2 AS sale_price_x2 FROM Product; 其实算术运算符的用法很简单，就不再多说了。 2.2.2 需要注意NULL 在进行算术运算时，如果对象中包含NULL值会是什么结果呢？结果是NULL，所有包含NULL的计算结果均为NULL，甚至包括NULL/0也会是NULL。有时我们会希望NULL能像0一样进行计算，这种方法存在，但会在很后面才学习，先空在这里。 2.2.3 比较运算符 其实在WHERE语句的代码中，就使用了=这个比较运算符。下面来使用不等号&lt;&gt;，一个例子： #选择sale_price列的值不是500的记录的product_name,product_type值 SELECT product_name, product_type FROM Product WHERE sale_price &lt;&gt; 500; SQL的比较运算符和Python的基本一样，唯一有区别的就是不等号是&lt;&gt;。下面再给个算术运算符和比较运算符结合使用的例子： #选择sale_price-purchase_price大于等于500的列的product_name,sale_price,purchase_price值 SELECT product_name, sale_price, purchase_price FROM Product WHERE sale_price-purchase_price &gt;= 500; 2.2.4 对字符串使用不等号的注意事项 对于字符串中的数字使用各种大于小于号会怎么样呢？下面先创建一个字符串表： #创建一个字符串表Chars，并输入字符串类型的数字数据 CREATE TABLE Chars (chr CHAR(3) NOT NULL, PRIMARY KEY (chr)); START TRANSACTION; INSERT INTO Chars VALUES ('1'); INSERT INTO Chars VALUES ('2'); INSERT INTO Chars VALUES ('3'); INSERT INTO Chars VALUES ('10'); INSERT INTO Chars VALUES ('11'); INSERT INTO Chars VALUES ('222'); 下面来试着进行使用比较运算符，如查询chr列中大于'2'的数据会发生什么呢？ #查询chr列中大于'2'的数据 SELECT chr FROM Chars WHERE chr &gt; '2'; 上面代码的结果是不是'3'，'10'，'11'，'222'呢？答案不是，代码只返回了'3'和'222'。原因在于&gt; '2'部分表示与字符串'2'进行比较，所以不会按照数字的大小规则，而是按照字符串的大小规则进行比较，即先比较第一个字符显然只有'3'比'2'大，而'222'与'2'相同故比较第二个字符，'222'此时大于'2'，其他的均不满足条件。如果真的要对字符串数字进行比较运算，要使用数字类型。如下才会返回'3'，'10'，'11'，'222'。 #查询chr列中大于2的数据 SELECT chr FROM Chars WHERE chr &gt; 2; 2.2.5 不能对NULL使用比较运算符 关于比较运算符还有一点就是不能对NULL值使用比较运算符。例如，purchase_price中有NULL值，下面来查询purchase_price不为2800的记录： #查询purchase_price不等于2800的行的product_name,purchase_price值 SELECT product_name, purchase_price FROM Product WHERE purchase_price &lt;&gt; 2800; 上面代码的结果并没有输出NULL值，原因是NULL表示不明，即无法判断是否等于2800。那如果想选择purchase_price为NULL的记录怎么办呢？ #查询purchase_price为NULL值的行的product_name,purchase_price值 SELECT product_name, purchase_price FROM Product WHERE purchase_price = NULL; 非常遗憾，上面代码的结果是一条记录也取不出来，就算把=换成&lt;&gt;也是一样。因此SQL提供了专门用来判断是否为NULL的IS NULL运算符。想要选取为NULL值时，应该如下使用： #查询purchase_price为NULL值的行的product_name,purchase_price值 SELECT product_name, purchase_price FROM Product WHERE purchase_price IS NULL; 反之，如果想选择不是NULL值得记录时： #查询purchase_price不为NULL值的行的product_name,purchase_price值 SELECT product_name, purchase_price FROM Product WHERE purchase_price IS NOT NULL; 对NULL的其他运算符使用方法将在第六章详细介绍。今天学完了第二章前两节，明天完结第二章并继续第三章的学习。 ","link":"https://wangykonne.github.io/post/sql-xue-xi-bi-ji-er/"},{"title":"SQL学习笔记（一）","content":" 今天开始搬运以前写过的SQL学习笔记，尽量一天一更吧~ 学习用书：SQL基础教程（Mick著） 数据库：MySQL 数据库可视化软件：SQLyog 第一章：数据库与SQL 1.1 SQL概要 1.1.1 SQL语句及其种类 SQL用关键字、表名、列名等组合而成的一条SQL语句来描述操作的内容。根据对RDBMS赋予的指令种类的不同，SQL语句可分为以下三类： DDL（数据定义语言）用来创建或者删除数据库、表等对象。例如：①CREATE，创建数据库和表等对象；②DROP，删除数据库和表等对象；③ALTER，修改数据库和表等对象的结构。 DML（数据操纵语言）用来查询或者变更表中的记录。例如：①SELECT：查询表中的数据；②INSERT：向表中插入新的数据；③UPDATE：更新表中的数据；④DELETE：删除表中的数据。 DCL（数据控制语言）用来确认或者取消对数据库中的数据进行的变更，以及设定RDBMS的用户是否有权限操作数据库中的对象。例如：①COMMIT：确认对数据库中的数据进行的变更；②ROLLBACK：取消对数据库中的数据进行的变更；③GRANT：赋予用户操作权限；④REVOKE：取消用户的操作权限。 上述数据中，DML的使用率最高。 1.1.2 SQL的基本书写规则 SQL的语句要以半角分号;结尾。 SQL语句不区分关键字的大小写，例如SELECT和select的意义相同。但是，插入到表中的数据是区分大小写的，例如数据'computer'和'COMPUTER'是不一样的。 字符串形式的数据要用单引号'括起来；数字直接书写即可。 单词之间要使用半角空格或者换行符进行分割。 1.2 表的创建 1.2.1 数据库的创建 通过CREATE DATABASE 语句可以创建数据库，如下创建一个名为shop的数据库： CREATE DATABASE shop; 1.2.2 表的创建 创建好数据库后，使用CREATE TABLE 语句在其中创建表格，如下： CREATE DATABASE learning; CREATE TABLE Product (product_id CHAR(4) NOT NULL, product_name VARCHAR(100) NOT NULL, product_type VARCHAR(32) NOT NULL, sale_price INTEGER , purchase_price INTEGER , regist_date DATE , PRIMARY KEY (product_id)); 上面代码含义之后会讲解。 1.2.3 命名规则 只能使用半角英文字母、数字、下划线_作为数据库、表和列的名称；此外，名称必须用半角英文字母开头；最后不能创建相同名称的数据库或者表或者表中的列名。 1.2.4 数据类型的指定 上面代码中，Product表所包含的列，定义在（）内。其中CHAR(4)，VARCHAR(100)等是用来声明列的数据类型的。注意，所有列都必须声明数据类型，且每一列都不能储存和该列数据类型不符合的数据。四种基本的数据类型为： INTEGER：用来指定储存的数据类型为整数，不能储存小数。 CHAR：用来指定储存的数据类型为字符型，括号内的数字表示可储存的字符串的最大长度，且字符串会以定长的形式储存。例如在CHAR(8)中输入'abc'的时候会以'abc+五个半角空格'的形式保存起来。 VARCHAR：同CHAR类型一样，VARCHAR也是用来储存字符型数据的，不同之处在于VARCHAR是用可变长的形式储存字符串，不会像CHAR一样进行半角空格的补长。注意：Oracle中使用VARCHAR2表示这种类型 DATE：用来储存日期（年月日）的列的数据类型。注意：Oracle中的DATE型还包括时分秒 1.2.5 约束的设置 除了数据类型外，在列中储存数据有时还要进行限制或者追加条件。在上面的代码中，product_id，product_name，product_type列都设置了NOT NULL的设置，表示这三列的数据不能输入空白，即必须输入数据。 另外，在上面的代码的最后设置了PRIMARY KEY (product_id)，表示把product_id设置主键约束。通俗的理解就是：如果把product_id设置为主键，就可以通过该列的值唯一确定一行数据，即不同行数据的product_id必须是不一样的。 1.3 表的删除和更新 1.3.1 表的删除 删除表的语句非常简单，只要DROP TABLE 即可： DROP TABLE Product; 需要注意的是，删除的表是无法恢复的，只能重新创建重新插入数据。所以要执行DROP TABLE 语句的时候要仔细确认。 1.3.2 表定义的更新 有时候创建表后如果想继续加入几列或者删除其中几列时，不需要删除表再重新创建，只需要使用ALTER TABLE 语句，例如在Product表中加入一列product_name_pinyin储存100位可变长的字符串： #在Product表中加入一列product_name_pinyin储存100位可变长的字符串 #DB2,PostgreSQL,MySQL ALTER TABLE Product ADD COLUMN product_name_pinyin VARCHAR(100); #Oracle ALTER TABLE Product ADD (product_name_pinyin VARCHAR2(100)); #SQL Server ALTER TABLE Product ADD product_name_pinyin VARCHAR(100); 特定的SQL中，Oracle和SQL Server中不需要写COLUMN，Oracle中需要使用括号且VARCHAR应改为VARCHAR2。另外，Oracle可以一次同时添加多列，如： ALTER TABLE &lt;表名&gt; ADD (&lt;列名1&gt; VARCHAR2(100), &lt;列名2&gt; VARCHAR2(100)...); 反之，删除表中某些列如下，例如删除之前添加的product_name_pinyin列： #在Product表中删除product_name_pinyin列 #DB2,SQL Server,MySQL,Postgre SQL ALTER TABLE Product DROP COLUMN product_name_pinyin; #Oracle ALTER TABLE Product DROP (product_name_pinyin); 特定的SQL中，Oracle不需要写COLUMN，且可以通过上面一样的操作同时删除多列。 1.3.3 向Product表中插入数据 上面创建了数据库learning，表Product，但表内容是空的，下面来向表中插入数据： #向Product表中插入数据 #SQL Server,Postgre SQL BEGIN TRANSACTION; INSERT INTO Product VALUES ('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20'); INSERT INTO Product VALUES ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'); INSERT INTO Product VALUES ('0003', '运动T恤', '衣服', 4000, 2800, NULL); INSERT INTO Product VALUES ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20'); INSERT INTO Product VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15'); INSERT INTO Product VALUES ('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20'); INSERT INTO Product VALUES ('0007', '擦菜板', '厨房用具', 880, 790, '2008-04-28'); INSERT INTO Product VALUES ('0008', '圆珠笔', '办公用品', 100, NULL, '2009-11-11'); COMMIT; #MySQL START TRANSACTION; INSERT INTO Product VALUES ('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20'); INSERT INTO Product VALUES ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'); INSERT INTO Product VALUES ('0003', '运动T恤', '衣服', 4000, 2800, NULL); INSERT INTO Product VALUES ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20'); INSERT INTO Product VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15'); INSERT INTO Product VALUES ('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20'); INSERT INTO Product VALUES ('0007', '擦菜板', '厨房用具', 880, 790, '2008-04-28'); INSERT INTO Product VALUES ('0008', '圆珠笔', '办公用品', 100, NULL, '2009-11-11'); COMMIT; #Oracle,DB2 INSERT INTO Product VALUES ('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20'); INSERT INTO Product VALUES ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'); INSERT INTO Product VALUES ('0003', '运动T恤', '衣服', 4000, 2800, NULL); INSERT INTO Product VALUES ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20'); INSERT INTO Product VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15'); INSERT INTO Product VALUES ('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20'); INSERT INTO Product VALUES ('0007', '擦菜板', '厨房用具', 880, 790, '2008-04-28'); INSERT INTO Product VALUES ('0008', '圆珠笔', '办公用品', 100, NULL, '2009-11-11'); COMMIT; 上面的代码对于不同的RDBMS会略有不同，例如SQL Server,Postgre SQL中开始指令为BEGIN TRANSACTION；MySQL中开始指令为START TRANSACTION；Oracle和DB2中不需要开始指令，直接用INSERT INTO &lt;表名&gt; VALUES (&lt;内容&gt;);开始。 1.3.4 修改表名 如果在匆忙中将Product输成了Poduct，又输入进了大量数据时，删除表再创建并输入数据会非常麻烦。大部分RDBMS中都提供了RENAME 指令来修改表名： #将表名Poduct修改为Product #Oracle,PostgreSQL ALTER TABLE Poduct RENAME TO Product; #DB2,MySQL RENAME TABLE Poduct TO Product; #SQL Server sp_rename 'Poduct', 'Product' 不同的RDBMS的RENAME指令的使用方法一般都不同，但都是按照修改前、修改后的名字来指定表名的。 今天学了第一章一些基础概念和一些基础操作，明天开始进入第二章：查询基础。同时，这些基础概念到后面的章节都会专门学习~ ","link":"https://wangykonne.github.io/post/sql-xue-xi-bi-ji-yi/"},{"title":"12.10 实习面经","content":" 面试公司：上海1药网股份有限公司 时长：约90分钟 结果：通过 面试题（一面）（应该是技术小哥来面试，很硬核的专业知识） Q1：详细介绍项目内容和具体算法的细节。 A1：（问到了很多模型细节方面的处理：如特征工程？现实意义？怎么评估模型？感觉回答的不是很好，被指出了很多待改进的地方） Q2：讲一下随机森林和决策树的区别？ A2：（概念问题，简而言之随机森林是决策树的一种bootstrap集成算法，采用自举样本、随机个特征同时进行多棵树的构建，最后把结果综合） Q3：接Q2，集成算法大体分为两种，一种就是你刚说的bootstrap，还有一种叫boosting，你了解过boosting的代表算法吗？ A3：（由于怕面试官考到细节知识和实现原理，我只说了听过Adaboost和Xgboost，具体原理还在学习中，毕竟还是知道多少说多少比较好） Q4：你觉得在数据挖掘的过程中，选择什么模型重要吗？ A4：（其实不是很懂面试官想问什么，我回答的是有一定重要程度，但面试官的答案是特征工程和如何获得干净的数据更重要，但他也没问哪个重要这种问题，不然我肯定也会说特征工程更重要...） Q5：你觉得数据挖掘中得到的变量重要性（因为在项目里提及过）在实际中应该怎么使用？ A5：（这里有点小卡壳，我回答的是可以重点关注这些指标，这些指标的高低可能会对预测变量有毕竟明显的影响，但面试官马上就问：那怎么衡量什么是高低呢？我就呆住.jpg了，确实没考虑这种问题，只好说视实际问题定...） Q6：在分类问题预测变量比例失衡下，accuracy还是一个科学的指标吗？你还知道哪些评估指标？ A6：（比较基础的理论，accuracy在比例失衡下不是个好的评估标准，可以采用召回率recall、精准度、f1分数、auc-roc值作为评估指标） Q7：SQL习题，有一个电商的仓库表，记录了省份、商品名、销售额。怎么查询各个省份销售量top10的商品（面试官表示不考虑销量相同的情况）？ A7：（说实话这道题不难，我写的是用rank窗口函数，partition by省份，order by销售额 desc就可以按省份分割并按销售额降序排列，最后使用where rank列的别名 &lt;=10即可。但一开始犯傻想用limit取10条，结果面试官提醒了一下这样只能取10条而不是每个省10条才用了where，实在是太弱了😭） 面试题（二面）（感觉是数据科学组的leader来面，虽然没问专业性特别强的问题，但气场很足，问的都是我的规划之类的） Q1：本科和研究生学了哪些统计学相关的课？ A1：（其实我本科真正和统计沾边的课只有概统和多元统计，其他的都是纯数的课，所以估计面试官也问不到什么知识，只问了研究生阶段的数据挖掘课一般学啥做啥） Q2：接触了数据科学后，你比较喜欢数分类的工作还是数据挖掘类的工作呢？以后的职业规划是怎样的？ A2：（其实说真的，我个人倾向于数分类的工作，毕竟我代码方面真的挺薄弱的，而且本科学算法与数据结构时候的痛苦现在还记得，可能实在是不太适合，不然我考研就跨CS了😭职业规划其实是想去自己喜欢的行业工作，比如一些游戏公司、b站这些我自己感兴趣的年轻领域，唉也不知道明年能不能实现Orz） Q3：自己对数据科学实习的工作预期是怎样的？ A3：（我回答的是，希望能在实习中得到锻炼，提高自己的coding能力和分析能力，而不是操作办公软件打杂。确实，这点我说的很直白，毕竟如果只是打杂当廉价劳动力而没有提升自己，那纯属浪费时间） Q4：介绍环节，讲了下公司数据科学团队的构成和日常工作 Q5：反问环节 A5：（①实习生的日常工作，我一直很关心这点，因为不想进来当Excel boy；②需要学习别的新软件吗？面试官说一般用python和SQL和R，可视化有时会用些BI软件） 面试题（三面）（普通的HR面，很轻松，聊天式） Q1：一些基本问题，感觉就像打招呼一样，例如：老家哪里的，是不是独生子女之类的... A1：（略） Q2：看到我是厦大的后，问我在厦大和交大的学习生活体验有什么不同？ A2：（我回答的大致意思是：大佬太多，我是乐色，以上🙃） Q3：如果来实习通勤大概多久？能坚持下来吗？ A3：（公司在张江高科，经典程序员之家，大概通勤90多分钟，挺远的。当然得回答能坚持下来） Q4：预期的实习薪资多少？ A4：（app上写的信息是200，所以我也回答的是200） Q5：有了解过公司吗？ A5：（没提前准备，只知道是卖药的公司，后面查了下，类似医药界的淘宝，还挺大的） Q6：为什么想实习？ A6：（锻炼自己解决实习问题的能力，同时实习也是职业规划上重要的一环！） Q7：用两个负面词语形容自己的话，你会选哪两个？为什么？ A7：（①内向不善沟通，②好强但又菜Orz） Q8：反问环节 A8：（问了下工作时间，有没有午饭。回答是早九晚六，午休一小时，没有午饭但有晚饭但晚饭要7点，啊这，经典诱惑员工加班！可恶！） 心得体会 这次面试的岗位叫数据科学实习生，听名字就能知道，偏挖掘一点，所以在心中的地位比任意门低了一点。尽管公司真的很大（独栋四层办公楼），而且也是上市公司前景也还不错，只是不是心中理想的行业吧（话说我在说什么，人家还没决定要收留我呢呜呜呜！）。目前总共面试两次，刚好就是一次数分一次数据挖掘，感受到的区别还是很大的，面数据挖掘岗还是一定要把自己写的项目全方位准备，基本面试官出题也就是从你的介绍中找出题点，所以要争取把项目上的所有可能的知识点尽可能全部准备。 ","link":"https://wangykonne.github.io/post/129-shi-xi-mian-jing-qi-er/"},{"title":"12.9 实习面经","content":" 面试公司：上海任意门科技有限公司 时长：约40分钟 结果：未知 面试题 Q1：就简历问了些项目的具体内容和工作 A1：（简历上的项目是研一上学期数据挖掘课的大作业，我把自己做的内容和工作都说明清楚就结束了，可能因为是商业数分类的岗位，没有问太多这方面的东西） Q2：你觉得数据分析和数据挖掘岗位有什么区别？ A2：（区别还是挺大的，自己答得挺顺的所以不记得具体说了啥，总之大概就是一个偏技术与理论一个偏产品和商业思维的区别） Q3：公司的核心产品是Soul APP，你觉得Soul APP的产品经理和分析团队每天需要观测哪些指标来分析产品是否有异常呢？ A3：（直击知识盲区，现场开始胡言乱语，我的回答是活跃用户、发动态数量这些基本的数据。最后面试官提了一个指标叫次流：表示第一天活跃的用户第二天还活跃的比例。涨姿势了！） Q4：Soul不同于微博，它的匿名性给了它一个去中心化产品的定位，你觉得数据上如何反应这种去中心化呢？ A4：（彻底懵圈，如果是Q3还能说点东西这道题就真的是硬编了...最后也没答到点上QAQ😭，面试官也没给答案，估计是觉得说了我也听不懂吧Orz） Q5：介绍一下SQL的窗口函数有哪些？ A5：（只回答了rank,dense_rank,row_number和聚合函数，面试官给我补充了lead和lag函数） Q6：说一下rank,dense_rank,row_number三者的区别？ A6：（比较简单，rank同次序会跳数，dense_rank同次序不会跳数，row_number不能同次序） Q7：紧接Q6，既然row_number不能同次序，那如果有两行完全一样谁前谁后呢？ A7：（我回答是按照主键或者索引定序，看面试官的表情应该是说对了） Q8：介绍一下内联结外联结和全联结 A8：（很简单的概念题，但是太紧张一开始把全联结说成交叉联结的定义了，呜呜呜😭） Q9：union和union all的区别？union可以对两个表中列名不同但数量相同对应数据类型也相同相关限制也相同数据含义也相同的列使用吗？ A9：（区别是是否对数据去重；可以使用） Q10：SQL题，一张表active_user，两列分别为用户uid和活跃时间（YYYY-MM-DD），求某一天的次流？ A10：（这道题我用了太多子查询被面试官说太麻烦，解答是将表active_user按uid左联结自己，查询两次活跃时间差为1天且活跃时间包括题干中的“某一天”的记录，最后select count(uid)，再除于某一天的前一天的活跃用户即可） Q11：反问环节 A11：（问了些有关工作内容的问题） 心得体会 公司环境还是很好的，很有年轻互联网公司内味。面试官也很Nice，回答不上商业的哪些题的时候他一直在提示我，虽然还是没说上来TAT。地理位置还是挺远的，一个半小时地铁才能到。工作内容主要是用SQL、Python进行数据分析，偶尔会进行数据挖掘，然后用Tableau进行数据可视化，写分析报告之类的。不过一般商业数分也都是这些活吧，只能说自己这方面的思维能力还要加强呀~ ","link":"https://wangykonne.github.io/post/129-shi-xi-mian-jing/"},{"title":"Hello World","content":" 成年人的第一个博客 经过两天的不懈努力，wyk终于把小站搭建好了，这几天真是被这种问题给整晕了😭顺便给其他想搭建github pages的同学一点人生经验：如果你用了Gridea渲染后github pages访问变得奇慢无比，请立即去github下载个靠谱的新主题！！ 没错，就是这个小小的问题困扰了我好几天（恼），我甚至在国内和国外都买了个域名，就差买个服务器了...马上考试和各种ddl都要来了，而我这几天都在整这个啥都没看😭。不说了，预计忙完这一阵子才会更新（或许想摸鱼的时候会搬运一些从前写的东西。 路漫漫其修远兮 建立这个小站呢，主要还是想监督自己学习，毕竟自己以前学习从来不做笔记，导致本科学过的很多东西如今都忘得差不多了。开学后受到同学的影响，开始试着写写笔记，然后发现写学习笔记其实是一种效率很高的办法。所以，为了督促自己学习，同时又能强化记忆，准备把这里作为自己的小图书馆👨‍🎓，短期目标是顺利通过期末和找到实习，长期目标是顺利毕业成为打工人👨‍💻。 let's start!（我真是High到不行啊！） ","link":"https://wangykonne.github.io/post/hello-world/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 其实一直以来都有建个主页的想法，但碍于自己不会前端技术只好作罢。直到在知乎上看到了Gridea，不得不说使用起来还是很方便的👍。目前计划是在空闲时候整理自己从前的学习笔记并放到Pages上来，当然了，以后学习的新东西也会整理好上传。除此之外，毕竟是属于自己的小站，当然也会记录一些生活啊学习方面的碎碎念吧。总之就是这样，路漫漫其修远兮，希望自己空闲时刻能坚持更新吧~ 👨‍💻 博主是谁 关键词：数学专业秃头学生，小镇做题家，国家级摸鱼运动员，新垣结衣圈外男友（？ ⛹ 兴趣爱好 打游戏（Arknights，联盟），看动漫，睡觉 📬 联系我呀 Github指路：wangykonne；微博指路：@-Kraiyyn ","link":"https://wangykonne.github.io/post/about/"}]}